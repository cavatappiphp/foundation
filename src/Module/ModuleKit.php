<?php

namespace Cavatappi\Foundation\Module;

use Cavatappi\Foundation\Exceptions\CodePathNotSupported;
use Cavatappi\Foundation\Service;
use ReflectionClass;
use ReflectionNamedType;

trait ModuleKit {
	/**
	 * Map of classes and the interfaces they implement.
	 *
	 * @var array<class-string, class-string[]>
	 */
	private static array $classInterfaceMap;

	/**
	 * Map of classes and the interfaces they implement.
	 *
	 * @var array<class-string, array<string, class-string|callable>|string|callable>
	 */
	private static array $serviceDependencyMap;

	/**
	 * Array of class name keys with the interfaces they implement.
	 *
	 * @return array<class-string, class-string[]>
	 */
	public static function discoverableClasses(): array {
		self::$classInterfaceMap ??= self::analyzeClasses(self::listClasses());
		return self::$classInterfaceMap;
	}

	/**
	 * Get the Services to be registered in this Model and their dependencies.
	 *
	 * @return array<class-string, array<string, class-string|callable>|string|callable>
	 */
	public static function serviceDependencyMap(): array {
		self::$serviceDependencyMap ??= self::mapServices(self::serviceMapOverrides());
		return self::$serviceDependencyMap;
	}

	/**
	 * Get the list of discoverable classes in this Module.
	 *
	 * @return class-string[]
	 */
	abstract private static function listClasses(): array;

	/**
	 * Get any overrides to the autogenerated service dependency map.
	 *
	 * @return array<class-string, array<string, class-string|callable>|string|callable>
	 */
	abstract private static function serviceMapOverrides(): array;

	/**
	 * Map the given classes to the interfaces they implement.
	 *
	 * @param  class-string[] $classNames Classes to parse.
	 * @return array<class-string, class-string[]>
	 */
	private static function analyzeClasses(array $classNames): array {
		$map = [];
		foreach ($classNames as $className) {
			$implements = \class_implements($className);
			if ($implements) {
				$map[$className] = $implements;
			}
		}
		return $map;
	}

	/**
	 * Get the Services defined in this DomainModel and their dependencies.
	 *
	 * @param  <class-string, array<string, class-string|callable>|string|callable> $overrides Classes
	 *                                                                                         to exclude from the automapping and any additions to the dependency map.
	 * @return array<class-string, array<string, class-string|callable>|string|callable>
	 */
	private static function mapServices(array $overrides = []): array {
		$overridden = \array_keys($overrides);
		$automapClasses = \array_keys(
			\array_filter(
				self::discoverableClasses(),
				fn($implements, $class) => !\in_array($class, $overridden) && \in_array(Service::class, $implements),
				ARRAY_FILTER_USE_BOTH
			)
		);

		$automapResults = [];
		foreach ($automapClasses as $classToMap) {
			$automapResults[$classToMap] = self::reflectService($classToMap);
		}

		return \array_merge($automapResults, $overrides);
	}

	/**
	 * Reflect the given service and return its dependency array.
	 *
	 * @throws CodePathNotSupported When service's constructor takes untyped or union/intersection typed arguments.
	 *
	 * @param  class-string $service Service to reflect.
	 * @return array<string, mixed>
	 */
	private static function reflectService(string $service): array {
		$reflect = (new ReflectionClass($service))->getConstructor();
		if (!isset($reflect)) {
			return [];
		}

		$params = [];
		foreach ($reflect->getParameters() as $param) {
			$type = $param->getType();
			if (!isset($type) || \get_class($type) !== ReflectionNamedType::class || $type->isBuiltin()) {
				throw new CodePathNotSupported(
					message: "{$service} cannot be auto-registered; parameter {$param->getName()} is not a class.",
					location: static::class . '::AUTO_SERVICES',
				);
			}

			$params[$param->getName()] = $type->getName();
		}

		return $params;
	}
}
